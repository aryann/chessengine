module;

#include <format>
#include <optional>
#include <string>
#include <string_view>

#include "absl/log/check.h"

export module types;

namespace chessengine {

// See `Bitboard` comment.
export enum Square : std::uint8_t {
  // clang-format off
  A8, B8, C8, D8, E8, F8, G8, H8,
  A7, B7, C7, D7, E7, F7, G7, H7,
  A6, B6, C6, D6, E6, F6, G6, H6,
  A5, B5, C5, D5, E5, F5, G5, H5,
  A4, B4, C4, D4, E4, F4, G4, H4,
  A3, B3, C3, D3, E3, F3, G3, H3,
  A2, B2, C2, D2, E2, F2, G2, H2,
  A1, B1, C1, D1, E1, F1, G1, H1,
  // clang-format on
};

using enum Square;

export constexpr std::size_t kRanks = 8;
export constexpr std::size_t kFiles = 8;
export constexpr std::size_t kNumSquares = kRanks * kFiles;

// Parses a string of the form "a1" as a Square. Returns `std::nullopt`
// if and only if the input is invalid.
export std::optional<Square> ParseSquare(std::string_view input) {
  if (input.size() != 2) {
    return std::nullopt;
  }

  char file = input[0];
  char rank = input[1];

  if (file < 'a' || file > 'h' || rank < '1' || rank > '8') {
    return std::nullopt;
  }

  int file_index = file - 'a';
  int rank_index = rank - '0';
  int square = (8 - rank_index) * 8 + file_index;
  return static_cast<Square>(square);
}

constexpr std::uint8_t GetRank(Square square) { return square / 8; }

constexpr std::uint8_t GetFile(Square square) { return square % 8; }

constexpr Square MakeSquare(std::uint8_t rank, std::uint8_t file) {
  DCHECK_GE(rank, 0);
  DCHECK_LT(rank, 8);
  DCHECK_GE(file, 0);
  DCHECK_LT(file, 8);

  return static_cast<Square>(rank * 8 + file);
}

constexpr Square Reflect(const Square square) {
  const int new_tank = 7 - GetRank(square);
  return static_cast<Square>(new_tank * 8 + GetFile(square));
}

export std::string ToString(Square square) {
  int rank = 8 - square / 8;
  char file = 'a' + square % 8;
  return file + std::to_string(rank);
}

// Required for GoogleTest to print Square in error messages.
inline void PrintTo(const Square &square, std::ostream *os) {
  *os << ToString(square);
}

enum Side : std::uint8_t {
  kWhite,
  kBlack,
  kEmptySide,
};

constexpr std::size_t kNumSides = 2;

constexpr Side operator~(Side side) { return side == kWhite ? kBlack : kWhite; }

export enum Direction : std::int8_t {
  kNorth = -8,
  kSouth = -kNorth,
  kEast = 1,
  kWest = -kEast,

  kNorthEast = kNorth + kEast,
  kNorthWest = kNorth + kWest,
  kSouthEast = kSouth + kEast,
  kSouthWest = kSouth + kWest,
};

enum Piece : std::uint8_t {
  kPawn,
  kKnight,
  kBishop,
  kRook,
  kQueen,
  kKing,
  kEmptyPiece,
};

// Required for GoogleTest to print Piece in error messages.
inline void PrintTo(const Piece &piece, std::ostream *os) {
  static std::string_view kPieceNames[] = {"P", "N", "B", "R", "Q", "K", "-"};
  *os << kPieceNames[piece];
}

constexpr std::size_t kNumPieces = 6;

enum class MoveType : std::uint8_t {
  kQuiet,
  kCapture,
  kEvasion,
};

using enum MoveType;

}  // namespace chessengine

template <>
struct std::formatter<chessengine::Square> : std::formatter<std::string> {
  static auto format(chessengine::Square square, std::format_context &context) {
    return std::format_to(context.out(), "{}", ToString(square));
  }
};
